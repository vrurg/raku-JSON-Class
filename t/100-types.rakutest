use v6.e.PREVIEW;
use Test::Async;
use JSON::Class:auth<zef:vrurg>;
use JSON::Class::X:auth<zef:vrurg>;
use JSON::Class::Config:auth<zef:vrurg>;
use JSON::Fast;

plan 5;

subtest "Version" => -> $subtest {
    plan 3;
    my class VFoo is json {
        has Version:D $.ver is required;
    }

    my $vfoo = VFoo.new(ver => v42.13.2);

    is $vfoo.to-json, q<{"ver":"42.13.2"}>, "Version serializes as a string";

    cmp-deeply VFoo.from-json(q«{"ver":"1.23.45"}»), VFoo.new(:ver(v1.23.45)), "version deserializes from a string";

    {
        CONTROL {
            when CX::Warn {
                $subtest.like: .message, /Version .* implicit .* JSONification/, "we're warned about Version JSONification";
            }
        }
        JSON::Class::Config.jsonify(Version).new("12.13.14").to-json;
    }
}

subtest "Setty" => {
    plan 2;
    for Set, SetHash -> \type {
        my $tname = type.^name;
        my \cclass = "my class C$tname is json \{ has $tname \$.s; }".EVAL;
        my @sets = (), ("a",), (<foo bar baz>);
        subtest $tname => {
            plan +@sets;
            for @sets -> @set {
                subtest "Set of " ~ +@set ~ " elements" => {
                    plan 3;
                    my $c = cclass.new(s => type.new(@set));
                    my $json = $c.to-json;
                    my %data = from-json($json);
                    ok %data<s>:exists, "attribute was serialized";
                    cmp-deeply %data<s>.sort, @set.sort, "keys are serialized";
                    cmp-deeply cclass.from-json($c.to-json), $c, "deserialized";
                }
            }
        }
    }
}

subtest "Baggy/Mixy" => {
    plan 4;
    for Bag, BagHash, Mix, MixHash -> \type {
        my $tname = type.^name;
        my \cclass = "my class C$tname is json \{ has $tname \$.qh; }".EVAL;
        my @sets = %(), %( a => 1.23 ), %(:foo(2.2), :bar(42), :baz(pi));
        subtest $tname => {
            plan +@sets;
            for @sets -> %set {
                subtest "Set of " ~ %set.elems ~ " elements" => {
                    plan 2;
                    my $c = cclass.new(qh => type.new-from-pairs(%set));
                    my $json = $c.to-json;
                    my %data = from-json($json);
                    my %expected = qh => type.new-from-pairs(%set).Hash;
                    cmp-deeply %data, %expected, "serialized";
                    cmp-deeply cclass.from-json($json).qh.Hash, $c.qh.Hash, "deserialized";
                }
            }
        }
    }
}

subtest "Prohibited JSONifications" => {
    my $config = JSON::Class::Config.new(:strict);
    my Mu @types = Promise, Supply, Channel, Lock, IO::Handle, IO::Socket::INET, IO::Pipe;
    plan +@types;

    for @types -> \typeobj {
        throws-like
            { $config.jsonify(typeobj) },
            JSON::Class::X::UnsupportedType,
            :type(typeobj),
            :message(*.contains: "cannot be implicitly JSONified"),
            typeobj.^name ~ " cannot be implicitly JSONified";
    }
}
subtest "Complex Hashes And Arrays" => {
    plan 1;
    my class Rec is json {
        has Int:D $.id is required;
        has Str:D $.payload is required;
        multi method new(Int:D $id, Str:D $payload) is raw {
            self.new: :$id, :$payload
        }
    }
    my class Cmplx is json(:implicit) {
        has Array[Rec:D] %.codes;
        has Hash[Rec:D, Int:D()] @.code-idx;
    }

    my $expected =
        Cmplx.new:
            codes =>
                ( "c1" => (my @ is Array[Rec:D] = Rec.new(11, "rec1"), Rec.new(21, "rec2")),
                "c2" => (my @ is Array[Rec:D] = Rec.new(12, "s1"), Rec.new(22, "s2")) ),
            code-idx =>
                ( (my % is Hash[Rec:D, Int:D()] = 331 => Rec.new(331, "rec100"), 32 => Rec.new(32, "rec101")),
                (my % is Hash[Rec:D, Int:D()] = 41 => Rec.new(41, "rec200"), 42 => Rec.new(42, "rec201")) )
            ;

    my $json = q<{"code-idx":[{"331":{"id":331,"payload":"rec100"},"32":{"id":32,"payload":"rec101"}},{"41":{"id":41,"payload":"rec200"},"42":{"id":42,"payload":"rec201"}}],"codes":{"c1":[{"id":11,"payload":"rec1"},{"id":21,"payload":"rec2"}],"c2":[{"id":12,"payload":"s1"},{"id":22,"payload":"s2"}]}}>;
    my $deserialized = Cmplx.from-json($json);
    cmp-deeply $deserialized, $expected, "deserialized";
}

done-testing;