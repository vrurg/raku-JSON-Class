use v6.e.PREVIEW;
use Test::Async;
use JSON::Class:auth<zef:vrurg>;
use JSON::Class::X:auth<zef:vrurg>;
use JSON::Class::Config:auth<zef:vrurg>;
use JSON::Fast;

plan 4;

subtest "Version" => -> \subtest {
    plan 3;
    my class VFoo is json {
        has Version:D $.ver is required;
    }

    my $vfoo = VFoo.new(ver => v42.13.2);

    is $vfoo.to-json, q<{"ver":"42.13.2"}>, "Version serializes as a string";

    cmp-deeply VFoo.from-json(q«{"ver":"1.23.45"}»), VFoo.new(:ver(v1.23.45)), "version deserializes from a string";

    {
        CONTROL {
            when CX::Warn {
                subtest.like: .message, /Version .* implicit .* JSONification/, "we're warned about Version JSONification";
            }
        }
        JSON::Class::Config.jsonify(Version).new("12.13.14").to-json;
    }
}

subtest "Setty" => {
    plan 2;
    for Set, SetHash -> \type {
        my $tname = type.^name;
        my \cclass = "my class C$tname is json \{ has $tname \$.s; }".EVAL;
        my @sets = (), ("a",), (<foo bar baz>);
        subtest $tname => {
            plan +@sets;
            for @sets -> @set {
                subtest "Set of " ~ +@set ~ " elements" => {
                    plan 3;
                    my $c = cclass.new(s => type.new(@set));
                    my $json = $c.to-json;
                    my %data = from-json($json);
                    ok %data<s>:exists, "attribute was serialized";
                    cmp-deeply %data<s>.sort, @set.sort, "keys are serialized";
                    cmp-deeply cclass.from-json($c.to-json), $c, "deserialized";
                }
            }
        }
    }
}

subtest "Baggy/Mixy" => {
    plan 4;
    for Bag, BagHash, Mix, MixHash -> \type {
        my $tname = type.^name;
        my \cclass = "my class C$tname is json \{ has $tname \$.qh; }".EVAL;
        my @sets = %(), %( a => 1.23 ), %(:foo(2.2), :bar(42), :baz(pi));
        subtest $tname => {
            plan +@sets;
            for @sets -> %set {
                subtest "Set of " ~ %set.elems ~ " elements" => {
                    plan 2;
                    my $c = cclass.new(qh => type.new-from-pairs(%set));
                    my $json = $c.to-json;
                    my %data = from-json($json);
                    my %expected = qh => type.new-from-pairs(%set).Hash;
                    cmp-deeply %data, %expected, "serialized";
                    cmp-deeply cclass.from-json($json).qh.Hash, $c.qh.Hash, "deserialized";
                }
            }
        }
    }
}

subtest "Prohibited JSONifications" => {
    my $config = JSON::Class::Config.new(:strict);
    my Mu @types = Promise, Supply, Channel, Lock, IO::Handle, IO::Socket::INET, IO::Pipe;
    plan +@types;

    for @types -> \typeobj {
        throws-like
            { $config.jsonify(typeobj) },
            JSON::Class::X::UnsupportedType,
            :type(typeobj),
            :message(*.contains: "cannot be implicitly JSONified"),
            typeobj.^name ~ " cannot be implicitly JSONified";
    }
}

done-testing;